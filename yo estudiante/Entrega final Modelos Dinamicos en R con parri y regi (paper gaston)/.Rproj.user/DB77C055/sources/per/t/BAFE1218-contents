### MODELO DE SOLOW ###
library(tidyverse)

######## en tiempo discreto (recursi?n) ########

### Condiciones iniciales
times=1000 # cantidad maxima de iteraciones
k = rep(0, times)
k[1] = 1
h = rep(0, times)
h[1] = 2
y = rep(0, times)
n = rep(0, times)
n[1] = 0.02 # crecimiento de la poblacion inicial
L = rep(0, times)
L[1] = 100 # tamaño inicial de la poblacion


# Buscar una forma de hacer variar los parametros y q se les adjudique los vectores resultantes



s_k = 0.25 # tasa de ahorro del capital fisico
s_h = 0.3# tasa de ahorro del capital humano
delta = 0.05 # tasa de depreciacion
alpha = runif(1) # parametro de eficiencia de escala del capital fisico
beta = 1-alpha # parametro de eficiencia de escala del capital humano



# Simulacion ----
s <- seq(0.1, 0.9, 0.05)

M = 300 # capacidad de carga
b = 0.2
c = 1 # c = 1 corresponds to ideal contest competition, the limit c → ∞ corresponds to ideal scramble competition and c > 1 corresponds to varying combinations of scramble and contest.

a = (M*b+1)^c


L.data <- matrix(0,times-1, length(s))
n.data <- matrix(0,times-1, length(s))
k.data <- matrix(0,times, length(s))      # matriz de ceros, con nrow=200 y ncol=2001
h.data <- matrix(0,times, length(s))
y.data <- matrix(0,times, length(s))


for (s_k in s) {
  k[1] = 1
  h[1] = 2
  n[1] = runif(1,0,0.04) # crecimiento de la poblacion inicial
  L[1] = 100 # tamaño inicial de la poblacion
  
for (t in 2:times) {
  L[t] <- (a*L[t-1]) / (1+b*L[t-1])^c
  n[t] <- (L[t]/L[t-1])-1 # tasa de crecimiento de la poblacion
  k[t] <- (s_k*y[t-1]+(1-delta)*k[t-1]) / (L[t]/L[t-1]) # evolucion de k
  h[t] <- (s_h*y[t-1]+(1-delta)*h[t-1]) / (L[t]/L[t-1]) # evolucion de h
  y[t] <- k[t]^alpha * h[t]^beta # funcion de produccion per capita
  
  L.data[t,n] <- L 
  n.data[t,n] <- n
  k.data[t,n] <- k
  h.data[t,n] <- h
  y.data[t,n] <- y
  }
  n <- n+1
}

M = 300 # capacidad de carga
b = 0.2
c = 1 # c = 1 corresponds to ideal contest competition, the limit c → ∞ corresponds to ideal scramble competition and c > 1 corresponds to varying combinations of scramble and contest.

a = (M*b+1)^c



## diagrama de bifurcación ----
n <- 1
R <- seq(2.5,4,length=2000)     # valores del parámetro de interés (renombramos "a" como "R")
f <- expression(a*x*(1-x))      # función a analizar
data <- matrix(0,200,2001)      # matriz de ceros, con nrow=200 y ncol=2001

for(a in R){
  x <- runif(1)                 # condición inicial
  ## convergencia al atractor (aplico la logística 200 veces para llegar al atractor)
  for(i in 1:200){
    x <- eval(f)                # le aplico la logística       
  } 
  # guardamos los puntos (simulamos 200 períodos más)
  for(i in 1:200){
    x <- eval(f)
    data[i,n] <- x              # guardo en cada momento n
  }
  n <- n+1                      # paso al período siguiente  
}

data <- data[,1:2000]           # elimino el valor inicial
plot(R,data[1,], pch=".", xlab="a", ylab="X",ylim=c(0,1),main="Diagrama de bifurcación")
segments(3,0,3,1)
segments(3.45,0,3.449,1)
segments(3.84,0,3.84,1)
text(x=c(3,3.449,3.84),y=c(0.01,0.01,0.01),labels = c("a=3","a=3.45","a=3.84"),col="blue",cex = 1.3)
for(i in 100:200) points(R,data[i,],pch=".")

# Especificaciones de leyes generales de poblacion ----
## Verhulst (1838) ----

r = 0.03
M = 300 # capacidad de carga

L[t] <- L[t-1]*exp(r*(1-(L[t-1])/M))  #Verhulst (1838)


## Beverton (1957) ----

M = 300 # capacidad de carga
b <- 0.08
a <- M*b+1

L[t] <- (a*L[t-1])/(1+b*L[t-1])

## Ricker (1954) ----

M = 300 # capacidad de carga
a = runif(1, 1, exp(2)) # para que converja a M tiene que: 1 < a < e^2 (7.389056)
b = log(a)/M

L[t] <- a*L[t-1]*exp(-b*L[t-1])

## Hassell (1975) ----
https://royalsocietypublishing.org/doi/10.1098/rsos.182178 # Hassell model

M = 300 # capacidad de carga
b = 0.2
c = 1 # c = 1 corresponds to ideal contest competition, the limit c → ∞ corresponds to ideal scramble competition and c > 1 corresponds to varying combinations of scramble and contest.
a = (M*b+1)^c

L[t] <- (a*L[t-1]) / (1+b*L[t-1])^c

# Equilibrio ----

k.star = ((s_k^(1-beta)*s_h^(beta))/(delta))^(1/(1-alpha-beta))
h.star = ((s_h^(1-alpha)*s_k^(alpha))/(delta))^(1/(1-alpha-beta))


# Graficos ----------------------------------------------------------------

plot(n,main="Tasa de crecimiento de la población")
plot(L,main="Tamaño de la población")

###### gr?ficos #######

ka=seq(0,15,0.1)
plot(ka,ka^alpha,type="l",xlab="k",ylab=" ",lwd=2,lty=3,col="blue",main="Modelo de Solow")
lines(ka,s*ka^alpha,col="red",lwd=2)
lines(ka,(delta+n[t])*ka,col="green",lwd=2)
segments(k[times],0,k[times],k[times]*(delta+n[t]),lty=2,lwd=2)

segments(k[times],k[times]*(delta+n[times]),k[times],k[times]^alpha,lty=3,lwd=2)

k_star=(s/(delta+n[times]))^(1/(1-alpha))
y_star=(s/(delta+n[times]))^(alpha/(1-alpha))

# evoluci?n de k 
plot(k,type="l",main="Evoluci?n de k",xlab="t")
segments(0,k_star,times,k_star,col="red",lty=3)

# evoluci?n de y
plot(y,type="l",main="Evoluci?n de y",xlab="t")
segments(0,y_star,times,y_star,col="red",lty=3)

# evoluci?n de la acumulaci?n de capital
plot(s*k^alpha-k*(delta+n[times]),ylab="s*f(k)-k*(delta+n)",
     main="Acumulaci?n de capital per c?pita",xlab="t")

